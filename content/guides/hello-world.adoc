= Hello World
Michael Nygard
2016-08-18
:jbake-type: page
:toc: macro
:icons: font
:section: guides

toc::[]

== Welcome

We're glad you've decided to give Pedestal a try. We think it's pretty
powerful. Before we get into the heavy lifting though, we should start
with some basics.

== What You Will Learn

After reading this guide, you will be able to:

- Create a Pedestal project from a template using Leiningen.
- Define a route.
- Return a page on that route.
- Accept and use URL parameters http://localhost:8080/hello?name=Michael.
- Return plain text or HTML in your response.

== Guide Assumptions

This guide is for beginners who are new to Pedestal. It doesn't assume
that you have any prior experience with Pedestal, Clojure, or any
other Clojure-based web framework. You should be familiar with the
basics of HTTP: URLs, response codes, and content types.

If you've already done some of those other things, you might want to
skip ahead to link:your-first-api[Your First API] to start building
some logic and multiple routes.

This guide also assumes that you are in a Unix-like development
environment, with Java installed. We've tested it on Mac OS X and
Linux (any flavor) with great results. We haven't yet tried it on the
Windows Subsystem for Linux, but would love to hear from you if you've
succeeded with it there.

== Getting Help If You're Stuck

We'll take this in small steps. If you get stuck at any point in this
guide, please submit an https://github.com/pedestal/docs/issues[issue]
about this guide or hop over to the
https://groups.google.com/forum/#!forum/pedestal-users[mailing list]
and raise your hand there.

== Where We Are Going

In this guide, we're going to take a series of small steps. We'll see
all the code to build a Pedestal service starting with an empty
directory.

The first time through, we will just do everything "by hand". This is
a little more work in typing (or copy-and-pasting) but it will let you
see how the pieces connect in the simplest possible use case.

Then we'll do the same thing but with power tools. We'll use a popular
build tool to create a project from a template. This one will have
some more bells and whistles to explore. We will look at what is
absolutely necessary, what is optional, and what benefits the template
offers.

Of course, nothing says you have to use this one official
template. Other people have set up their own templates, specialized
for different purposes. Since Pedestal is just a set of libraries, you
have a lot of flexibility in how you weave them together to make an
application. The link:../community/tutorials-guides-samples[Tutorials,
Guides, and Samples] page has links to some other templates that users
have created.

== Before We Begin

Pedestal services are written in Clojure code, which you then run on a
Java Virtual Machine. You will need to have a Java Runtime Environment
installed on your computer. Let's make sure you're up to date. Fire up
a terminal and put in this command:

----
$ java -version
----

You should see some output like this:

----
openjdk version "1.8.0_91"
OpenJDK Runtime Environment (build 1.8.0_91-8u91-b14-3ubuntu1~16.04.1-b14)
OpenJDK 64-Bit Server VM (build 25.91-b14, mixed mode)
----

Yours might vary in some of the details. For comparison, I'm running on
a http://linuxmint.org[Linux Mint] virtual machine.

The main thing is that I actually _got_ some output! If you get
"Command not found" or some variation of that, you probably need to
http://www.oracle.com/technetwork/indexes/downloads/index.html#java[install
Java].

The second thing is to make sure that the Java version is at least
1.7.

OK, so now that you are ready to run Java applications, let's move on
to the Pedestal part.

== Starting From Scratch

We're going to start this project with an empty directory. In
practice, most of the time you'll generate a project from a
template. But for now, it's more important to see what the pieces are
and how they fit together.

I'm going to call my project 'hello-world'. Feel free to call yours
something different, but it's up to you to do the mental translation
in the rest of this guide.

----
mkdir hello-world
cd hello-world
----

A quick note on naming style. Clojure itself uses "kebab case" for its
names. That's lowercase words, separated with hyphens. When you have a
long name, it looks like the letters have been skewered. Hence, kebab
case. Since Clojure's own libraries use this style, most applications
and libraries do too.

We need a place to keep our code. By convention, that's in a "src"
directory:

----
mkdir src
----

== A Place to Put Things

Now we're going to create a file under "src" to hold our code. Call it
"src/hello.clj". It's going to start with a "namespace declaration". This
tell Clojure what namespace to put the code into. (If you're a Java
programmer, you can think of a namespace as similar to a package
name.)

[source, clojure]
.src/hello.clj
----
(ns hello                                                      ;; <1>
  (:require [io.pedestal.http :as http]                        ;; <2>
            [io.pedestal.http.route.definition :as [routes]])) ;; <3>
----
<1> This namespace is called 'hello'. This almost always matches the filename.
<2> We need to use the 'io.pedestal.http' namespace, but would like to only type 'http' later in the file.
<3> We need to use the 'io.pedestal.http.route.definition' namespace, but would like to spell it as 'routes' later in the file.

This is very similar to using "import" in Java or "require" in
Ruby. It just makes some names from other namespaces available to us
in this namespace.

If you haven't written any Clojure before, this syntax might look a
little strange. The first thing that jumps out at people is the
parentheses. Why is there an open paren _before_ the "ns"? In Clojure,
every expression is enclosed in its very own set of parentheses. There
are no semicolons to end the line or curly braces to close an "if"
expression. To find the end of any expression, you just find the
matching paren.

The first "thing" in an expression is the function or a macro to call.
In this case `ns` is a macro that is built in to Clojure. It sets up a
namespace and makes the stuff we `require` available.

Speaking of the stuff we require, what is `io.pedestal.http` and
`io.pedestal.http.route.definition`? Those are each namespaces from
Pedestal libraries. The
link:/api/pedestal.service/io.pedestal.http.html[`io.pedestal.http`]
namespace has functions that let you connect with HTTP servers, handle
requests, and send responses. The
link:/api/pedestal.route/io.pedestal.http.route.html[`io.pedestal.http.route.definition`]
namespace actually comes from a library dedicated to routing
(ingeniously named `pedestal.route`.)

Routing is split off into its own library because you can use it by
itself, or you can use the HTTP library with a different routing
layer. We won't need to do that in this guide, but other tutorials do
some pretty amazing things by substituting modules.

== Generating a Response

Whew. That was a lot to unpack from just the first three lines of
code! Let's pause for a moment to talk about the next steps. We're
making a web service that can say hello. That means we need to do some
basic things:

1. Listen to on a socket for HTTP requests.
2. Figure out what any given request means.
3. Make a response to that request.

We're going to do all of those things, but we're going to do them
/backwards/. In Clojure, you always find the most important,
highest-level functions at the _bottom_ of the file. Whenever I read a
Clojure source file, I start at the bottom and page upward. So the
next thing we're going to do is write a function that can return a
response to a "hello world" request.

[source, clojure]
.src/hello.clj
----
(defn hello [request]                  ;; <1>
  {:status 200 :body "Hello, world!"}) ;; <2>
----
<1> Define a function called `hello` that takes one argument, which we will call `request`
<2> Return a map with two keys and two values.

A Clojure function returns the value of the last expression in the
function. In this case, that will be the map that we construct on line
2. This is in "map literal" syntax, which just means that we're
writing the whole map straight in the source code rather than building
it up by calling functions.

The map has two keys and their values:

* `:status` 200
* `:body`   "Hello, world!"

That's the whole thing. When our function returns that map, Pedestal
will translate that into a full HTTP response complete with content
type header and everything. (Later on, we'll see how to take control
of the whole response. For now we're just taking the easy road.)

There's absolutely nothing special about this map. It's a plain old
Clojure map. The /keys/ on the other hand, do mean something. They are
part of the "response map" specification, which you can
link:/reference/response-map[read about].

In fact, you can call this function without hooking it up to a socket
or route or anything. That's one of the beauties of working in
Pedestal... you can try everything interactively in a running
system. Let's do that before we move on.

== Managing Dependencies

Pedestal is built on the shoulders of giants, in the form of great
open source technology that many people have contributed to. That
gives us great power, but with great power comes great
dependencies. We could download all the jar files we need and string
together a classpath, but it's a huge pain. I just made a minimal
project and found 57 entries on the classpath.

This is why we /can/ have nice things, but it means we need some help
managing those dependencies. We're going to use help in the form of
http://boot-clj.com/[boot-clj]. Please take a few minutes to go follow
their https://github.com/boot-clj/boot#install[installation
instructions], then come back and we'll continue.

Now we can make a build file that tells boot what libraries our service needs:

[[app-listing]]
[source,clojure]
.build.boot
----
(set-env!
 :resource-paths #{"src"}                                   ;; <1>
 :dependencies   '[[io.pedestal/pedestal.service "0.5.0"]   ;; <2>
                   [io.pedestal/pedestal.route   "0.5.0"]
                   [io.pedestal/pedestal.jetty   "0.5.0"]])
----
<1> Tell Boot where our source code lives
<2> Tell Boot we need three Pedestal libraries

We talked about `pedestal.service` and `pedestal.route` before, but we
have a new one here. Pedestal works with many different HTTP servers,
so we don't want the core library to depend on _all_ of the possible
servers out there. Instead, we let you decide which one to use by
adding the library for your chosen service. We'll use Jetty for this
guide, but many others are available.
